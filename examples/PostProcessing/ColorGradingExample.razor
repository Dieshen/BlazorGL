@page "/examples/color-grading"
@using BlazorGL.Core
@using BlazorGL.Core.Cameras
@using BlazorGL.Core.Geometries
@using BlazorGL.Core.Lights
@using BlazorGL.Core.Materials
@using BlazorGL.Core.Rendering
@using BlazorGL.Extensions.PostProcessing
@using System.Numerics

<PageTitle>Color Grading with LUT - BlazorGL</PageTitle>

<div class="example-container">
    <div class="canvas-wrapper">
        <canvas id="lut-canvas" width="@_width" height="@_height"></canvas>
    </div>

    <div class="controls">
        <h3>LUT Color Grading</h3>

        <div class="control-group">
            <label>LUT Preset:</label>
            <select @onchange="OnLUTPresetChanged">
                <option value="neutral">Neutral (No Grading)</option>
                <option value="warm">Warm</option>
                <option value="cool">Cool</option>
                <option value="sepia">Sepia</option>
            </select>
        </div>

        <div class="control-group">
            <label>Intensity: @_intensity.ToString("F2")</label>
            <input type="range" min="0" max="1" step="0.01" value="@_intensity"
                   @oninput="OnIntensityChanged" />
        </div>

        <div class="control-group">
            <label>LUT Size:</label>
            <select @onchange="OnLUTSizeChanged" value="@_lutSize">
                <option value="16">16³ (Low)</option>
                <option value="32">32³ (Medium)</option>
                <option value="64">64³ (High)</option>
            </select>
        </div>

        <div class="info">
            <h4>About LUT Color Grading</h4>
            <p>
                <strong>Lookup Tables (LUTs)</strong> are 3D textures that map input colors to output colors,
                allowing for complex color transformations in a single texture lookup.
            </p>

            <h4>Common Uses</h4>
            <ul>
                <li>Cinematic color grading</li>
                <li>Film emulation</li>
                <li>Mood/atmosphere creation</li>
                <li>Color correction</li>
                <li>Stylized rendering</li>
            </ul>

            <h4>LUT Size Trade-offs</h4>
            <ul>
                <li><strong>16³:</strong> Fast, lower precision</li>
                <li><strong>32³:</strong> Balanced quality/performance</li>
                <li><strong>64³:</strong> High precision, more memory</li>
            </ul>

            <h4>Custom LUTs</h4>
            <p>
                You can load custom .cube files exported from:
            </p>
            <ul>
                <li>Adobe Photoshop</li>
                <li>DaVinci Resolve</li>
                <li>After Effects</li>
                <li>Any LUT-compatible software</li>
            </ul>
        </div>
    </div>
</div>

@code {
    private int _width = 1280;
    private int _height = 720;

    private Renderer? _renderer;
    private Scene? _scene;
    private PerspectiveCamera? _camera;
    private EffectComposer? _composer;
    private LUTPass? _lutPass;

    private float _intensity = 1.0f;
    private int _lutSize = 16;
    private string _currentPreset = "neutral";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeScene();
            await Render();
        }
    }

    private async Task InitializeScene()
    {
        // Create renderer
        _renderer = new Renderer(_width, _height);
        await _renderer.InitializeAsync("lut-canvas");

        // Create scene
        _scene = new Scene();

        // Create camera
        _camera = new PerspectiveCamera(75, (float)_width / _height, 0.1f, 100f);
        _camera.Position = new Vector3(0, 2, 8);
        _camera.LookAt(Vector3.Zero);

        // Add lights
        var ambientLight = new AmbientLight(0xffffff, 0.6f);
        _scene.Add(ambientLight);

        var directionalLight = new DirectionalLight(0xffffff, 0.8f);
        directionalLight.Position = new Vector3(5, 10, 5);
        _scene.Add(directionalLight);

        // Create colorful test scene
        CreateColorfulScene();

        // Setup post-processing
        _composer = new EffectComposer(_renderer);
        _composer.AddPass(new RenderPass(_scene, _camera));

        // Add LUT pass
        _lutPass = new LUTPass(_width, _height)
        {
            Intensity = _intensity,
            LUTSize = _lutSize
        };
        _composer.AddPass(_lutPass);
    }

    private void CreateColorfulScene()
    {
        if (_scene == null) return;

        // Create spheres with different colors to show LUT effects
        var colors = new uint[]
        {
            0xff0000, // Red
            0x00ff00, // Green
            0x0000ff, // Blue
            0xffff00, // Yellow
            0xff00ff, // Magenta
            0x00ffff, // Cyan
            0xff8000, // Orange
            0x8000ff  // Purple
        };

        int cols = 4;
        int rows = 2;
        float spacing = 2.5f;

        for (int i = 0; i < colors.Length; i++)
        {
            int col = i % cols;
            int row = i / cols;

            var geometry = new SphereGeometry(0.6f, 32, 32);
            var material = new MeshStandardMaterial
            {
                Color = colors[i],
                Metalness = 0.3f,
                Roughness = 0.4f
            };

            var sphere = new Mesh(geometry, material);
            sphere.Position = new Vector3(
                (col - cols / 2.0f + 0.5f) * spacing,
                (row - rows / 2.0f + 0.5f) * spacing,
                0
            );
            _scene.Add(sphere);
        }

        // Add ground plane
        var planeGeometry = new PlaneGeometry(15, 15);
        var planeMaterial = new MeshStandardMaterial
        {
            Color = 0x808080,
            Roughness = 0.8f
        };
        var plane = new Mesh(planeGeometry, planeMaterial);
        plane.Rotation = new Vector3(-MathF.PI / 2, 0, 0);
        plane.Position = new Vector3(0, -2, 0);
        _scene.Add(plane);
    }

    private async Task Render()
    {
        if (_composer == null || _scene == null) return;

        float rotation = 0;

        while (true)
        {
            // Slowly rotate scene
            rotation += 0.005f;
            foreach (var child in _scene.Children)
            {
                if (child is Mesh mesh && mesh.Geometry is SphereGeometry)
                {
                    mesh.Rotation = new Vector3(0, rotation, 0);
                }
            }

            _composer.Render();
            await Task.Delay(16); // ~60 FPS
        }
    }

    private void OnLUTPresetChanged(ChangeEventArgs e)
    {
        var preset = e.Value?.ToString();
        if (preset == null || _lutPass == null) return;

        _currentPreset = preset;

        switch (preset)
        {
            case "neutral":
                _lutPass.SetNeutralLUT();
                break;
            case "warm":
                _lutPass.LUT = LUTLoader.PresetLUTs.Warm(_lutSize);
                break;
            case "cool":
                _lutPass.LUT = LUTLoader.PresetLUTs.Cool(_lutSize);
                break;
            case "sepia":
                _lutPass.LUT = LUTLoader.PresetLUTs.Sepia(_lutSize);
                break;
        }
    }

    private void OnIntensityChanged(ChangeEventArgs e)
    {
        if (float.TryParse(e.Value?.ToString(), out var value) && _lutPass != null)
        {
            _intensity = value;
            _lutPass.Intensity = value;
        }
    }

    private void OnLUTSizeChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value) && _lutPass != null)
        {
            _lutSize = value;
            _lutPass.LUTSize = value;

            // Reload current preset with new size
            OnLUTPresetChanged(new ChangeEventArgs { Value = _currentPreset });
        }
    }
}

<style>
    .example-container {
        display: flex;
        gap: 20px;
        padding: 20px;
    }

    .canvas-wrapper {
        flex: 1;
    }

    canvas {
        width: 100%;
        height: auto;
        border: 1px solid #ccc;
    }

    .controls {
        width: 350px;
        padding: 20px;
        background: #f5f5f5;
        border-radius: 8px;
    }

    .control-group {
        margin-bottom: 20px;
    }

    .control-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }

    .control-group select,
    .control-group input[type="range"] {
        width: 100%;
    }

    .info {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #ddd;
    }

    .info h4 {
        margin-top: 20px;
        margin-bottom: 10px;
    }

    .info ul {
        margin-top: 8px;
        padding-left: 20px;
    }

    .info li {
        margin-bottom: 6px;
    }
</style>
